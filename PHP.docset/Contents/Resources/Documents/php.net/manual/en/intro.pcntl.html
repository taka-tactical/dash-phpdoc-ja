<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>はじめに</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="book.pcntl.html">PCNTL</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="pcntl.setup.html">インストール/設定</a></div>
 <div class="up"><a href="book.pcntl.html">PCNTL</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="intro.pcntl" class="preface">
  <h1 class="title">はじめに</h1>
  <p class="para">
   PHP がサポートするプロセス制御関数は、Unix 形式のプロセス生成、
   プロセス実行、シグナル処理、プロセス終了機能を実装しています。
   プロセス制御は Web サーバー環境で有効にするべきではなく、プロセス
   制御関数のどれかが Web サーバー環境で使用された場合には、予期しない結果を
   生じる可能性があります。
  </p>
  <p class="para">
   この文書は、プロセス制御関数の一般的な使用法を説明しようとするものです。
   Unix のプロセス制御に関する詳細な情報については、fork(2),
   waitpid(2) および signal(2) のようなシステムのドキュメントや、
   W. Richard Stevens による Advanced Programming in the UNIX Environment (Addison-Wesley)
   のような優れた参考書を読まれることを推奨します。
  </p>
  <p class="para">
   現在 PCNTL はシグナルハンドルコールバックの仕組みとして ticks を
   使用しており、これは以前の仕組みよりずっと高速です。この変更は
   &quot;user ticks&quot; を使用するのと同じことです。<span class="function"><strong>declare()</strong></span>
   を使用して、プログラム中でコールバックの発生を許可する場所を指定する
   必要があります。これにより、非同期のイベントを処理する際の
   オーバーヘッドを最小限に抑えることが可能となります。以前は、pcntl を
   有効にして PHP をコンパイルすると、pcntl の使用の有無にかかわらず
   常にこのオーバーヘッドの被害を被っていたのです。
  </p>
  <p class="para">
   PHP 4.3.0 より前のバージョンで pcntl を使用していたすべてのスクリプトに
   ついて、1 点だけ修正する必要があります。それは、コールバックを許可
   したい場所に <span class="function"><strong>declare()</strong></span> を使用するか、あるいは
   <span class="function"><strong>declare()</strong></span> の新しいグローバル書式を使用して
   スクリプト全体で ticks を有効にすることです。
  </p>

  <blockquote class="note"><p><strong class="note">注意</strong>: <span class="simpara">この拡張モジュールは Windows
環境では利用できません。</span></p></blockquote>
 </div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="119474""></a>
  <div class="note">
   <strong class="user">Rick Sustek</strong>
   <a href="#119474" class="date">16-Jun-2016 06:02</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Actually it makes perfect sense why process control features are not supported for the Apache module. The Apache HTTP server is the chief process. It invokes the PHP module when steered to PHP by the resource requested (e.g. <a href="http://foo.php" rel="nofollow" target="_blank">http://foo.php</a>) It invokes the PHP module, typically on a new thread or a pooled thread. The PHP module then runs your script, but Apache server is still the owning process.<br />
<br />
In this execution model, the job of your PHP script is generally to go about its business as fast as possible and return. This allows the Apache daemon to do something else useful with the thread it let you borrow. Yes, some scripts take longer to do their duty than others, but blocking the thread for extended periods is usually frowned upon.<br />
<br />
If your script was allowed to mess with the signal handlers of the running process, it would be messing with the Apache daemon itself! That daemon has already installed signal handlers for its own use. It is just plain sense not to allow the process control operations in this context.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="107127""></a>
  <div class="note">
   <strong class="user">sean dot kelly at mediatile dot com</strong>
   <a href="#107127" class="date">09-Jan-2012 10:32</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
The following statement left me searching for answers for about a day before I finally clued in:<br />
<br />
"Process Control should not be enabled within a web server environment and unexpected results may happen if any Process Control functions are used within a web server environment."<br />
<br />
At least for PHP 5.3.8 which I am using, and who knows how far back, it's not a matter of "should not", it's "can not". Even though I have compiled in PCNTL with --enable-pcntl, it turns out that it only compiles in to the CLI version of PHP, not the Apache module. As a result, I spent many hours trying to track down why function_exists('pcntl_fork') was returning false even though it compiled correctly. It turns out it returns true just fine from the CLI, and only returns false for HTTP requests. The same is true of ALL of the pcntl_*() functions.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="book.pcntl.html">PCNTL</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="pcntl.setup.html">インストール/設定</a></div>
 <div class="up"><a href="book.pcntl.html">PCNTL</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
